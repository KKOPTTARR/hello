#include <stdio.h>
#include <windows.h>

int main()
{
	//1. 基本概念
	//如果是整形，补码
	//无符号：原码 = 反码 = 补码
	//有符号正数：原码 = 反码 = 补码，最高位代表符号位，正(0)
	//有符号负数：最高位代表符号位，负(1)，需要进行原反补转化
	//原码: 对应数据的绝对值对应的二进制序列，特殊：有符号数，其中最高位要被设置成符号位
	//反码：符号位不变其他位，按位取反（默认是有符号负数）
	//补码：反码+1（符号位要参与运算，即便通常很少会影响到符号位）
	char a = 10;  //0000 1010 -> 0x0A
	char b = 20;  //0001 0100 -> 0x14
	//char c = -10; //1000 1010 -> 1111 0101 -> 1111 0110 -> 0xF6
	//2. 深入理解写入的过程
	//上面的原反补约束的是原始数据！！！
	//先给d开辟空间
	//要将数据转化成对应的二进制，此时转化的过程和目标变量无关！！
	//目标数据写到对应的开辟好的空间里
	//完成
	unsigned char d = -10; //0xF6

	//3. 使用它，读取他
	//在读取一个变量的时候，是该变量的类型，决定了我们(打印出来的结果)如何看对该变量内部的
	//二进制序列的含义！！不论你如何看待二进制序列，二进制序列本身是不发生变化的，但是经过类型解释
	//二进制代表的含义是会发生对应的变化的。
	//这也就是类型的意义
	printf("%u\n", d); //246

	//4. 总结：
	//   定义变量，本质是在开辟对应的空间
	//   写入数据：本质是现将数据转化成对应的二进制序列(与目标变量无关)，然后写入对应的内存空间里
	//   读入数据：本质是根据变量的类型，来解释内存里面的二进制是什么含义
	//   变量的类型起什么作用：1. 开辟空间时决定开辟的大小 2. 读取数据的时候，决定如何解释二进制（并不影响二进制内部任何数据）
	//   那么，如何读取一个变量(v1版本)：1. 先看变量的类型(确定是否有符号位)
	//                                   2. 如果是无符号数，直接转成十进制（任何你想看到的进制） 
	//                                   3. 如果是有符号数，先看符号位，如果符号位为0， 整数，同上
	//                                   4. 如果是有符号数，先看符号位，如果符号位为1, 先-1， 在符号位不变，整体按位取反
	char c = 255;     //1111 1111 -> 1111 1110 -> 1000 0001 -> -1
	printf("%d\n", c);

	//5. 
	int x = -10;
	//不需要，因为已经放在变量里面了，也就是说，原反补已经转化过了，所以对应的变量间的赋值，纯粹是二进制基本的赋值
	int y = x;
	unsigned z = x;









	//void 不能用来定义变量，但是能用来作为函数返回值，表示无类型返回
	//void*能定义变量，甚至能赋值，说明void*本身给变量开辟了空间
	//but! void*对应的变量不能被直接解引用！！！
	//有什么用？  void*非常特殊的应用，就是void*可以用来接收任意类型，常用于接收任意指针
	//void *x = NULL; 
	//x = (void*)10;
	//void x;
	//printf("%d\n", sizeof(void));
	system("pause");
	return 0;
}